### 技术栈

1. vu3
2. pinia状态管理
3. router路由跳转
4. eslint代码格式化
5. Element plus
6. vueUse

### 别名路径联想

1. jsconfig进行联想

```
{
  "compilerOptions": {
    // 自动联想路径
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "exclude": ["node_modules", "dist"]
}
```

2. vite.config.js进行路径转换

```
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
  ],
  resolve: {
    // 实际的路径转换 @ -> src
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})
```

### element plus使用步骤

1. 安装`npm install element-plus --save`
2. 配置按需引入(自动)

- 安装插件`npm install -D unplugin-vue-components unplugin-auto-import`
- 配置文件

   ```
   // vite.config.ts
    import { defineConfig } from 'vite'
    import AutoImport from 'unplugin-auto-import/vite'
    import Components from 'unplugin-vue-components/vite'
    import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

    export default defineConfig({
      // ...
      plugins: [
        // ...
        AutoImport({
          resolvers: [ElementPlusResolver()],
        }),
        Components({
          resolvers: [ElementPlusResolver()],
        }),
      ],
    })
   ```

3. 测试组件

### 自动导入样式文件&&更改主题色

使用sass配色系统

1. 安装sass `npm i sass -D`
2. 准备定制化的样式文件

```
/* 只需要重写你需要的即可 */
//文件路径：src\styles\element\index.scss
@forward 'element-plus/theme-chalk/src/common/var.scss' with (
  $colors: (
    'primary': (
      // 主色
      'base': #27ba9b,
    ),
    'success': (
      // 成功色
      'base': #1dc779,
    ),
    'warning': (
      // 警告色
      'base': #ffb302,
    ),
    'danger': (
      // 危险色
      'base': #e26237,
    ),
    'error': (
      // 错误色
      'base': #cf4444,
    ),
  )
)
```

3. 自动导入配置

```
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

//Elementplus自动按需引入
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'


// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    //配置插件
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [
        //1.配置elementPlus采用sass样式配色系统
        ElementPlusResolver({ importStyle: "sass" }),
      ],
    }),
  ],
  resolve: {
    // 实际的路径转换 @ -> src
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  css: {
    preprocessorOptions: {
      scss: {
        // 2.自动导入定制化样式文件进行样式覆盖掉原来的主题色
        additionalData: `
          @use "@/styles/element/index.scss" as *;
          @use "@/styles/var.scss" as *;
        `,
      }
    }
  }
})
```

### 配置axios拦截器

```
//路径：src\utils\http.js
//axios基础的封装
import axios from 'axios'

//创建axios实例
const httpInstance = axios.create({
    baseURL: 'http://pcapi-xiaotuxian-front-devtest.itheima.net',
    timeout: 5000
})

//拦截器

// axios请求拦截器
httpInstance.interceptors.request.use(config => {
    return config
}, e => Promise.reject(e))

// axios响应式拦截器
httpInstance.interceptors.response.use(res => res.data, e => {
    return Promise.reject(e)
})

export default httpInstance
```

测试接口

```
import httpInstance from "@/utils/http"

export function getCategory(){
    // 调用axios实例httpInstance，进行接口测试
    return httpInstance({
        url:'home/category/head'
    })
}
```

### 路由设计

**设计原则：**

- 找内容切换区域，如果页面整体切换，则为一级路由。
- 如果在一级路由页内切换则为二级路由,默认二级路由设置为path:''

### eslint规则

- 如当Login文件夹下的文件名为index.vue时，出现报错
  解决方法：在.eslintrc.cjs下添加

  ```
  rules: {
    'vue/multi-word-component-names': 0,// 不再强制要求组件命名
  }
  ```

### 就近原则创建组件文件夹

如：Layout的组件直接在Layout下创建一个component文件夹
然后再到index.vue渲染组件

### 使用iconfont

1.index.html的head引入,链接地址网站获取`<link rel="stylesheet" href="//at.alicdn.com/t/font_2143783_iq6z4ey5vu.css">`
2.在i标签中的class引入`<i class="iconfont icon-xxx"></i>`

```
<a href="javascript:;">
  <i class="iconfont icon-footer01"></i>
  <span>价格亲民</span>
</a>
```

### 吸顶导航实现

- 准备一个静态导航组件，根据滚动距离用v-show实现渲染
- 滚动距离根据`VueUse`的useScroll获得`const {y} = useScroll(window)`

### 新鲜好物和人气推荐实现组件复用

1. 不做任何抽象，准备静态模板
2. 抽象可变部分
   - 主标题和副标题为文本，prop传入
   - 主题内容比较复杂，slot传入
实现：
创建一个HomePanel组件，HomeNew和HomeHot共同调用。分别在HomeNew和HomeHot引入HomePanel组件，再利用prop和插槽传递数据

### 图片懒加载，进入视口区域才加载图片

实现人气推荐进入视口区才加载
指令：`v-img-lazy`
判断图片是否进入视口区域vueUse -> 如果图片进入视口，发生图片资源请求

```
//定义全局指令v-img-lazy
app.directive('img-lazy',{
  mounted(el,binding){
    //el:指令绑定的元素 img
    //binding：binding.value 指令等于号后面绑定的表达式的值 图片url
    console.log(el,binding.value)
    //判断是否进入视口useIntersectionObserver
    useIntersectionObserver(
      el,
      ([{ isIntersecting }]) => {
        // console.log(isIntersecting)
        if(isIntersecting){
          //进入了视口区域，给元素el添加属性src
          el.src = binding.value
        }
      },
    )
  }
})

//使用：
<img v-img-lazy="item.picture" alt="">
```

为简单入口文件main.js复杂度：
在directives文件夹下定义插件index.js

```
//index.js
//定义懒加载插件
import { useIntersectionObserver } from '@vueuse/core'

export const lazyPlugin = {
  install(app) {
    //懒加载指令逻辑
    app.directive('img-lazy', {
      mounted(el, binding) {
        //el:指令绑定的元素 img
        //binding：binding.value 指令等于号后面绑定的表达式的值 图片url（item.picture）
        console.log(el, binding.value)
        //判断是否进入视口useIntersectionObserver
        const {stop} = useIntersectionObserver(
          el,
          ([{ isIntersecting }]) => {
            // console.log(isIntersecting)
            if (isIntersecting) {
              //进入了视口区域，绑定的指令v-img-lazy给元素el添加属性src，item.picture就是binding.value
              //<img v-img-lazy="item.picture" alt="">
              el.src = binding.value
              stop() //监听加载图片完毕，停止监听避免造成内存浪费
            }
          },
        )
      }
    })
  }
}
```

### 点击header的分类没有高亮（激活状态）

给<RouterLink></RouterLink>配置active-class="active"

```
// 激活时的样式
.active {
  color: $xtxColor;
  border-bottom: 1px solid $xtxColor;
}
```

### 各分类页说明

- 接口接受到的数据有10个分类项，每个分类渲染到header上。
- 接口数据的每个分类下又有children，children下是页面下所有子分类的数据

- 路由已经进行了params传参占位配置
- Header的分类按钮，每次点击一个按钮，根据接口中的数据，按钮进行路由跳转，每个分类有自己的跳转id。
- category/index.js根据不同的id，传入接口根据id进行调整。

### 路由缓存问题***

> 使用带有参数的路由时，路由只有参数变化，相同的组件实例将被复用，导致生命周期不会再被调用。如：当从`/user/a`导航到`/user/b`时，相同的组件实例将被复用。
> 因为2个路由都渲染同个组件，比起销毁再创建，复用显得更高效。但也意味着生命周期钩子不会被调用 。

>该项目中点击header分类时，只进行了路由参数切换，但不会发生跳转。原因是进行了组件实例复用，没有调用生命周期钩子，故不跳转。

解决思路：

1. 让组件实例不复用，强制销毁重建，易浪费。使用`:key="$route.fullPath"`，为key添加完整路径
此操作会导致整个页面重新加载所有数据，但banner所有分类页都一样，不需要重新加载，会造成资源浪费。

```
//Layout/index.vue
<template>
  <LayoutFixed />
  <LayoutNav />
  <LayoutHeader />
  <!-- 二级路由出口，如分类页 -->
   <!-- 添加key 破坏复用机制 强制销毁重建 -->
  <RouterView :key="$route.fullPath" />
  <LayoutFooter />
</template>
```

2. 监听路由变化，变化之后执行数据更新操作。可以减少网络请求，精细化处理路由跳转后的数据加载
  在路由更新之前执行
  //路由一变化就监听到
  onBerforeRouteUpdate()
以下操作只更新category数据而不更新banner数据

```
//默认参数为route.params.id
const getcategoryData = async (id = route.params.id) => {
  const res = await getCategoryAPI(id) //route.params.id：因为路由用占位符（params传参），所以用route.params.id获取当前路由id
  categoryData.value = res.result
  console.log("res", res)
}

onMounted(() => {
  getcategoryData()
})

//目标:路由参数变化时，可以把分类数据接口重新发送getcategoryData
//to:目标路由对象
onBeforeRouteUpdate((to) => {
  console.log('路由变化了')
  //使用最新的路由参数请求最新的分类数据
  getcategoryData(to.params.id)
})
```

### 使用逻辑函数拆分业务

**跟hook一样**
函数和文件名use开头，封装通用业务，再把需要的方法和数据return出来

- 分类业务   useCategory
- banner业务 useBanner

### 点击二级分类页进行筛选排序切换

```
//请求参数
const reqData = ref({
  categoryId: route.params.id,
  page: 1,
  pageSize:20,
  sortField:'publishTime'
})

//tab切换回调
const tabChange = () => {
  console.log("tabChange",reqData.value.sortField)
  reqData.value.page = 1
  //sortField变了，重新发送请求
  getGoodList()
}

<el-tabs v-model="reqData.sortField" @tab-click="tabChange">
  <el-tab-pane label="最新商品" name="publishTime"></el-tab-pane>
  <el-tab-pane label="最高人气" name="orderNum"></el-tab-pane>
  <el-tab-pane label="评论最多" name="evaluateNum"></el-tab-pane>
</el-tabs>
```

### 无限加载

> Element Plus提供的**v-infinite-scroll="方法名"**指令监听是否满足触底条件，满足加载条件时让页数参数加一,获取下一页数据，做新老数据拼接渲染

基础思路

1. 触底条件满足之后 page++，拉取下一页数据
2. 新老数据做数组拼接
3. 判断是否已经全部加载完毕，停止监听

```
//请求参数
const reqData = ref({
  categoryId: route.params.id,
  page: 1, //页数，每次请求通过+1实现无限加载
  pageSize:20,
  sortField:'publishTime'
})
```

```
// 加载更多
const disabled = ref(false)
const load = async () => {
  console.log('加载更多数据咯')
  // 获取下一页的数据
  reqData.value.page++
  const res = await getSubCategoryAPI(reqData.value)
  goodList.value = [...goodList.value, ...res.result.items]
  // 加载完毕 停止监听
  if (res.result.items.length === 0) {
    disabled.value = true
  }
}
```
