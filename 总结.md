### 技术栈

1. vu3
2. pinia状态管理
3. router路由跳转
4. eslint代码格式化
5. Element plus
6. vueUse

### 别名路径联想

1. jsconfig进行联想

```
{
  "compilerOptions": {
    // 自动联想路径
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "exclude": ["node_modules", "dist"]
}
```

2. vite.config.js进行路径转换

```
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
  ],
  resolve: {
    // 实际的路径转换 @ -> src
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})
```

### element plus使用步骤

1. 安装`npm install element-plus --save`
2. 配置按需引入(自动)

- 安装插件`npm install -D unplugin-vue-components unplugin-auto-import`
- 配置文件

   ```
   // vite.config.ts
    import { defineConfig } from 'vite'
    import AutoImport from 'unplugin-auto-import/vite'
    import Components from 'unplugin-vue-components/vite'
    import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

    export default defineConfig({
      // ...
      plugins: [
        // ...
        AutoImport({
          resolvers: [ElementPlusResolver()],
        }),
        Components({
          resolvers: [ElementPlusResolver()],
        }),
      ],
    })
   ```

3. 测试组件

### 自动导入样式文件&&更改主题色

使用sass配色系统

1. 安装sass `npm i sass -D`
2. 准备定制化的样式文件

```
/* 只需要重写你需要的即可 */
//文件路径：src\styles\element\index.scss
@forward 'element-plus/theme-chalk/src/common/var.scss' with (
  $colors: (
    'primary': (
      // 主色
      'base': #27ba9b,
    ),
    'success': (
      // 成功色
      'base': #1dc779,
    ),
    'warning': (
      // 警告色
      'base': #ffb302,
    ),
    'danger': (
      // 危险色
      'base': #e26237,
    ),
    'error': (
      // 错误色
      'base': #cf4444,
    ),
  )
)
```

3. 自动导入配置

```
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

//Elementplus自动按需引入
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'


// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    //配置插件
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [
        //1.配置elementPlus采用sass样式配色系统
        ElementPlusResolver({ importStyle: "sass" }),
      ],
    }),
  ],
  resolve: {
    // 实际的路径转换 @ -> src
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  css: {
    preprocessorOptions: {
      scss: {
        // 2.自动导入定制化样式文件进行样式覆盖掉原来的主题色
        additionalData: `
          @use "@/styles/element/index.scss" as *;
          @use "@/styles/var.scss" as *;
        `,
      }
    }
  }
})
```

### 配置axios拦截器

```
//路径：src\utils\http.js
//axios基础的封装
import axios from 'axios'

//创建axios实例
const httpInstance = axios.create({
    baseURL: 'http://pcapi-xiaotuxian-front-devtest.itheima.net',
    timeout: 5000
})

//拦截器

// axios请求拦截器
httpInstance.interceptors.request.use(config => {
    return config
}, e => Promise.reject(e))

// axios响应式拦截器
httpInstance.interceptors.response.use(res => res.data, e => {
    return Promise.reject(e)
})

export default httpInstance
```

测试接口

```
import httpInstance from "@/utils/http"

export function getCategory(){
    // 调用axios实例httpInstance，进行接口测试
    return httpInstance({
        url:'home/category/head'
    })
}
```

### 路由设计

**设计原则：**

- 找内容切换区域，如果页面整体切换，则为一级路由。
- 如果在一级路由页内切换则为二级路由,默认二级路由设置为path:''

### eslint规则

- 如当Login文件夹下的文件名为index.vue时，出现报错
  解决方法：在.eslintrc.cjs下添加

  ```
  rules: {
    'vue/multi-word-component-names': 0,// 不再强制要求组件命名
  }
  ```

### 就近原则创建组件文件夹

如：Layout的组件直接在Layout下创建一个component文件夹
然后再到index.vue渲染组件

### 使用iconfont

1.index.html的head引入,链接地址网站获取`<link rel="stylesheet" href="//at.alicdn.com/t/font_2143783_iq6z4ey5vu.css">`
2.在i标签中的class引入`<i class="iconfont icon-xxx"></i>`

```
<a href="javascript:;">
  <i class="iconfont icon-footer01"></i>
  <span>价格亲民</span>
</a>
```

### 吸顶导航实现

- 准备一个静态导航组件，根据滚动距离用v-show实现渲染
- 滚动距离根据`VueUse`的useScroll获得`const {y} = useScroll(window)`

### 新鲜好物和人气推荐实现组件复用

1. 不做任何抽象，准备静态模板
2. 抽象可变部分
   - 主标题和副标题为文本，prop传入
   - 主题内容比较复杂，slot传入
实现：
创建一个HomePanel组件，HomeNew和HomeHot共同调用。分别在HomeNew和HomeHot引入HomePanel组件，再利用prop和插槽传递数据

### 图片懒加载，进入视口区域才加载图片

实现人气推荐进入视口区才加载
指令：`v-img-lazy`
判断图片是否进入视口区域vueUse -> 如果图片进入视口，发生图片资源请求

```
//定义全局指令v-img-lazy
app.directive('img-lazy',{
  mounted(el,binding){
    //el:指令绑定的元素 img
    //binding：binding.value 指令等于号后面绑定的表达式的值 图片url
    console.log(el,binding.value)
    //判断是否进入视口useIntersectionObserver
    useIntersectionObserver(
      el,
      ([{ isIntersecting }]) => {
        // console.log(isIntersecting)
        if(isIntersecting){
          //进入了视口区域，给元素el添加属性src
          el.src = binding.value
        }
      },
    )
  }
})

//使用：
<img v-img-lazy="item.picture" alt="">
```

为简单入口文件main.js复杂度：
在directives文件夹下定义插件index.js

```
//index.js
//定义懒加载插件
import { useIntersectionObserver } from '@vueuse/core'

export const lazyPlugin = {
  install(app) {
    //懒加载指令逻辑
    app.directive('img-lazy', {
      mounted(el, binding) {
        //el:指令绑定的元素 img
        //binding：binding.value 指令等于号后面绑定的表达式的值 图片url（item.picture）
        console.log(el, binding.value)
        //判断是否进入视口useIntersectionObserver
        const {stop} = useIntersectionObserver(
          el,
          ([{ isIntersecting }]) => {
            // console.log(isIntersecting)
            if (isIntersecting) {
              //进入了视口区域，绑定的指令v-img-lazy给元素el添加属性src，item.picture就是binding.value
              //<img v-img-lazy="item.picture" alt="">
              el.src = binding.value
              stop() //监听加载图片完毕，停止监听避免造成内存浪费
            }
          },
        )
      }
    })
  }
}
```

### 点击header的分类没有高亮（激活状态）

给`<RouterLink></RouterLink>`配置active-class="active"

```css
// 激活时的样式
.active {
  color: $xtxColor;
  border-bottom: 1px solid $xtxColor;
}
```

### 各分类页说明

- 接口接受到的数据有10个分类项，每个分类渲染到header上。
- 接口数据的每个分类下又有children，children下是页面下所有子分类的数据

- 路由已经进行了params传参占位配置
- Header的分类按钮，每次点击一个按钮，根据接口中的数据，按钮进行路由跳转，每个分类有自己的跳转id。
- category/index.js根据不同的id，传入接口根据id进行调整。

### 路由缓存问题***

> 使用带有参数的路由时，路由只有参数变化，相同的组件实例将被复用，导致生命周期不会再被调用。如：当从`/user/a`导航到`/user/b`时，相同的组件实例将被复用。
> 因为2个路由都渲染同个组件，比起销毁再创建，复用显得更高效。但也意味着生命周期钩子不会被调用 。

> 该项目中点击header分类时，只进行了路由参数切换，但不会发生跳转。原因是进行了组件实例复用，没有调用生命周期钩子，故不跳转。

解决思路：

1. 让组件实例不复用，强制销毁重建，易浪费。使用`:key="$route.fullPath"`，为key添加完整路径
此操作会导致整个页面重新加载所有数据，但banner所有分类页都一样，不需要重新加载，会造成资源浪费。

```vue
//Layout/index.vue
<template>
  <LayoutFixed />
  <LayoutNav />
  <LayoutHeader />
  <!-- 二级路由出口，如分类页 -->
   <!-- 添加key 破坏复用机制 强制销毁重建 -->
  <RouterView :key="$route.fullPath" />
  <LayoutFooter />
</template>
```

2. 监听路由变化，变化之后执行数据更新操作。可以减少网络请求，精细化处理路由跳转后的数据加 载
  在路由更新之前执行
  //路由一变化就监听到
  onBerforeRouteUpdate()
以下操作只更新category数据而不更新banner数据

```js
//useCategory.js
//默认参数为route.params.id
const getcategoryData = async (id = route.params.id) => {
  const res = await getCategoryAPI(id) //route.params.id：因为路由用占位符（params传参），所以用route.params.id获取当前路由id
  categoryData.value = res.result
  console.log("res", res)
}

onMounted(() => {
  getcategoryData()
})

//目标:路由参数变化时，可以把分类数据接口重新发送getcategoryData
//to:目标路由对象
onBeforeRouteUpdate((to) => {
  console.log('路由变化了')
  //使用最新的路由参数请求最新的分类数据
  getcategoryData(to.params.id)
})
```

### 使用逻辑函数拆分业务

**跟hook一样**
函数和文件名use开头，封装通用业务，再把需要的方法和数据return出来

- 分类业务   useCategory
- banner业务 useBanner

### 点击二级分类页进行筛选排序切换

```js
//请求参数
const reqData = ref({
  categoryId: route.params.id,
  page: 1,
  pageSize:20,
  sortField:'publishTime'
})

//tab切换回调
const tabChange = () => {
  console.log("tabChange",reqData.value.sortField)
  reqData.value.page = 1
  //sortField变了，重新发送请求
  getGoodList()
}

<el-tabs v-model="reqData.sortField" @tab-click="tabChange">
  <el-tab-pane label="最新商品" name="publishTime"></el-tab-pane>
  <el-tab-pane label="最高人气" name="orderNum"></el-tab-pane>
  <el-tab-pane label="评论最多" name="evaluateNum"></el-tab-pane>
</el-tabs>
```

### 无限加载

> Element Plus提供的**v-infinite-scroll="方法名"**指令监听是否满足触底条件，满足加载条件时让页数参数加一,获取下一页数据，做新老数据拼接渲染

基础思路

1. 触底条件满足之后 page++，拉取下一页数据
2. 新老数据做数组拼接
3. 判断是否已经全部加载完毕，停止监听

```js
//请求参数
const reqData = ref({
  categoryId: route.params.id,
  page: 1, //页数，每次请求通过+1实现无限加载
  pageSize:20,
  sortField:'publishTime'
})
```

```js
// 加载更多
const disabled = ref(false)
const load = async () => {
  console.log('加载更多数据咯')
  // 获取下一页的数据
  reqData.value.page++
  const res = await getSubCategoryAPI(reqData.value)
  goodList.value = [...goodList.value, ...res.result.items]
  // 加载完毕 停止监听
  if (res.result.items.length === 0) {
    disabled.value = true
  }
}
```

### 定制路由滚动行为

即切换路由时，页面滚回顶部
vue-router支持scrollBehavior()配置项

```js
//路由滚动行为定制
scrollBehavior(){
  return{
    top:0
  }
}
```

### 详情页的路由跳转

首先点击商品图片（如新鲜好物），它被用`<RouterLink>`包起来，to="`/detail/{item.id}`",路由根据该路径匹配到详情页组件，详情页组件通过route.params.id获取当前id，然后传入接口获取对应商品数据

```js
import {useRoute} from 'vue-router'

const route = useRoute()
```

> 同一个静态结构渲染多个不同内容的页面，用不同id区分并渲染数据。渲染哪个页面就要获取哪个页面的id

### 详情页错误

错误原因： goods刚开始是空的 ，导致`goods.categories.[1].id`goods还没加载出数据就.category往后运算，就会报错
1.可选链语法?.(`?.`前面存在时，才往后计算)

```vue
<el-breadcrumb-item :to="{ path: `/category/${goods.categories?.[1].id}` }">{{ goods.categories?.[1].name }}</el-breadcrumb-item>
<el-breadcrumb-item :to="{ path: `/category/sub/${goods.categories?.[0].id}` }">{{ goods.categories?.[0].name }}</el-breadcrumb-item>
```

2.*v-if控制渲染时机，只有数据存在才渲染
`<div class="container" v-if="goods.details">`

### 详情页的24小时热榜和周热榜获取不同数据

通过props

```vue

<!-- 24小时 -->
<DetailHot :hot-type="1"/>
<!-- 周热榜 -->
<DetailHot :hot-type="2"/>

//适配数据
//接收数据
const props = defineProps({
  hotType: {
    type: Number
  },
})
//key:value
const TYPEMAP = {
  1: '24小时热榜',
  2: '周热榜'
}
//TYPEMAP是对象，通过key访问其对应的value
const title = computed(() => TYPEMAP[props.hotType] )
```

### 详情页小图切换大图

绑定mouseenter事件，动态类绑定激活状态类

### 详情页放大镜

#### 蒙层实现

1. 获取鼠标在盒子内的相对位置（vueUse的useMouseInElement（elementX,elementY，isOutside）
2. 控制滑块移动跟随鼠标
1.有效移动距离
横向：100 < elementX < 300,left = elementX-小滑块宽度一半
纵向：100 < elementY < 300,left = elementY-小滑块高度一半
2.边界距离控制
横向：elementX>300 left=200。 elementX<100 left=0
纵向：elementY>300  top=200。 elementY<100 top=0
大图大小为400*400

```
// 3.控制滑块跟随鼠标移动
const left = ref(0)
watch([elementX,elementY],()=>{
  // console.log('鼠标移动了')
  //有效范围内控制滑块距离 
  //横向
  if(elementX.value > 100 && elementX.value < 300){
    left.value = elementX.value - 100
  }
  //纵向
  if(elementY.value > 100 && elementY.value < 300){
    top.value = elementX.value - 100
  }

  //控制大图的显示
  positionX.value = -left.value * 2
  positionY.value = -top.value * 2
})
```

#### 放大实现

(代码在上)
效果：为实现放大效果，大图的宽高是小图的两倍
思路：：大图的移动方向和滑块的移动方向相反，且位移数值为2倍
> 样式的动态绑定必须用对象`:style="{}"`
> 用v-if或者v-show根据isOutside控制滑块和放大图的展示

### 通用组件全局注册

通过插件的方式：

1.安装插件

```
//components/index.vue
//把components中的所有组件进行全局注册
//通过插件的方式

import ImageView from './ImageView/index.vue'
import Sku from './Sku/index.vue'

export const componentPlugin = {
  install(app){
    //app.component('组件名',组件配置对象)
    app.component('ShopImageView',ImageView)
    app.component('ShopSku',Sku)
  }
}
```

2.注册插件

```
//main.js
//引入全局组件插件并且注册
import {componentPlugin} from '@/components/index.vue'

app.use(componentPlugin) // 注册
```

### 表单校验

前端提前进行表单校验可以省去一些错误的请求提交，减少后端的请求次数
elemet-form 配置rules

#### 自定义校验规则

- 登录页协议框校验，勾选与否

```
validator:(rule,value,callback) => {
  //自定义校验逻辑
  //value：当前输入的数据
  //callback：校验处理函数 校验通过调用
}
```

```
const rules = {
  account: [
    { required: true, message: '用户名不能为空', trigger: 'blur' }
  ],
  password: [
    { required: true, message: '密码不能为空', trigger: 'blur' },
    { min: 6, max: 14, message: '密码长度为6~14个字符', trigger: 'blur' }
  ],
  //自定义校验规则
  agree:[
    {
      validator:(rule,value,callback)=>{
        console.log(value)
        //自定义校验规则，勾选？
        if(value){
          callback()
        }else{
          callback(new Error('请勾选协议'))
        }
      }
    }
  ]
}
```

#### 整个表单内容的校验

```
//3.获取form实例进行表单校验
const formRef = ref(null)
const login = () => {
  //调用实例方法validate
  formRef.value.validate((valid)=>{
    //valid:所有表单通过校验才为true
    console.log(valid)
  })
}
```

```
<el-form ref="formRef"><el-form>
```

表单验证：
> 用户名密码：简单应用现成配置规则
> 勾选协议：自定义配置规则 配置validator:(rule,valid,callback)=>{},成功则直接callback(),失败则callback(new Error('xxx'))
> 整体表单验证（登录时需要整体验证）：获取表单实例，调用实例方法validate(valid),根据valid判断是否通过验证

### push和replace的区别

对历史记录的影响：

push方法会将新的路由添加到历史记录中，允许用户通过返回按钮返回到当前页面。这意味着，当用户使用浏览器的后退按钮时，他们会返回到push操作之前的页面。
replace方法则会替换当前的路由，不会将新的路由添加到历史记录中。因此，用户无法通过返回按钮返回到被替换的页面。使用replace进行导航后，点击返回按钮不会回到被替换的页面。
页面返回的行为：

push操作后，用户可以通过浏览器的后退按钮正常地浏览历史记录，回到push操作之前的页面。
replace操作后，由于它替换了当前的历史记录条目，而不是添加一个新的条目，因此点击返回按钮的行为将取决于被替换的页面是否还在历史记录中。如果被替换的页面不在历史记录中，用户将无法通过返回按钮返回到该页面。

### 登录结果提醒

用ElMessage进行提醒，ElMessage是API，只使用组件 API，需要手动导入样式。

```
import 'element-plus/es/components/message/style/css'
import { ElMessage } from 'element-plus'
```

1. 登录成功时，按顺序执行。识别就会阻塞

```
//3.获取form实例进行表单统一校验
const formRef = ref(null)
const router = useRouter() //获取路由器实例
const login = () => {
  //获取登录信息
  const { account, password } = form.value

  //调用实例方法validate
  formRef.value.validate(async (valid) => {
    //valid:所有表单通过校验才为true
    console.log(valid)
    //通过校验？
    if (valid) {
      //登录跳转
      const res = await loginAPI({ account, password })
      console.log(res)
      //1.提示用户登录成功
      ElMessage({type:'success',message:'登录成功'})
      //2.跳转首页
      router.replace({path:'/'})
    }
  })
}
```

2. 登录失败时，统一通过后端返回数据，用拦截器进行统一处理

```
// axios请求拦截器
httpInstance.interceptors.request.use(config => {
    return config
}, e =>{return Promise.reject(e)})

// axios响应式拦截器
httpInstance.interceptors.response.use(res => res.data, e => {
  //统一错误提示  
  ElMessage({type:'warning',message:e.response.data.message})
  return Promise.reject(e)
})
```

### 用户数据pinia管理

```
export const useUserStore = defineStore('user', () => {
  //1.定义管理用户数据的store
  const userInfo = ref({})
  //2.定义获取接口数据的action函数
  const getUserInfo = async ({ account, password }) => {
    const res = await loginAPI({ account, password }) //登录后返回的是用户信息
    userInfo.value = res.result
  }
  //3.以对象的格式把store和action return出去
  return{
    userInfo,
    getUserInfo
  },
  {
    persist: true, //持久化插件配置，默认存localStorage
  }
})
```

#### 用户数据持久化管理

> pinia的持久化存储插件：pinia-plugin-persistedstate
> store添加一个配置项`persist: true`如上
> 获取数据优先从localStorage中去取

用token进行标识用户登录状态
pinia是基于内存的，刷新就丢失数据。而cookie和localStorage则是基于缓存的，可以持久化存储
